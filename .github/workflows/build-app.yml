# Build Raven Checkers:
# - Linux: Nuitka standalone -> AppImage (images embedded) packed with training/ into ONE tar.gz
# - macOS: Nuitka onefile -> tar.gz containing binary + training/ (images embedded)
# - Windows: Nuitka onefile -> zip containing exe + training/ (images embedded)

name: Build Application

on:
  push:
    tags:
      - "v[0-9]+.*"

permissions:
  contents: write

env:
  GITHUB_TOKEN: ${{ github.token }}
  APP_NAME: "raven-checkers"
  DIST_DIR_NAME: "RavenCheckers"

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-22.04
            platform: linux
            python-version: "3.12"
          - os: macos-latest
            platform: macos
            python-version: "3.12"
          - os: windows-latest
            platform: windows
            python-version: "3.12"

    steps:
      - name: Check out repository
        uses: actions/checkout@v5

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          architecture: "x64"
          cache: "pip"
          cache-dependency-path: |
            **/pyproject.toml

      - uses: seanmiddleditch/gha-setup-vsdevenv@master
        if: matrix.os == 'windows-latest'

      - name: Install system Tk (Ubuntu only)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          sudo apt-get update -y
          sudo apt-get install -y python3-tk
        shell: bash

      - name: Export runtime requirements from pyproject.toml
        run: |
          python - <<'PY'
          import tomllib
          from pathlib import Path

          data = tomllib.loads(Path("pyproject.toml").read_text(encoding="utf-8"))
          deps = data.get("project", {}).get("dependencies", [])
          Path("requirements-ci.txt").write_text("\n".join(deps) + "\n", encoding="utf-8")
          print("Wrote requirements-ci.txt with", len(deps), "deps")
          PY
        shell: bash

      - name: Install dependencies
        run: |
          python -m pip install -U pip
          python -m pip install -r requirements-ci.txt
          python -m pip install nuitka
        shell: bash

      - name: Sanity check Tk import
        run: |
          python -c "import tkinter; print('ok', tkinter.TkVersion)"
        shell: bash

      # ---- Build with Nuitka ----
      - name: Build Executable with Nuitka (Linux - standalone)
        if: matrix.os == 'ubuntu-22.04'
        uses: Nuitka/Nuitka-Action@main
        with:
          nuitka-version: main
          script-name: main.py
          mode: standalone
          output-file: ${{ env.APP_NAME }}
          enable-plugins: tk-inter
          include-data-dir: |
            images=images

      - name: Build Executable with Nuitka (macOS - onefile)
        if: matrix.os == 'macos-latest'
        uses: Nuitka/Nuitka-Action@main
        with:
          nuitka-version: main
          script-name: main.py
          mode: onefile
          output-file: ${{ env.APP_NAME }}
          enable-plugins: tk-inter
          include-data-dir: |
            images=images

      - name: Build Executable with Nuitka (Windows - onefile)
        if: matrix.os == 'windows-latest'
        uses: Nuitka/Nuitka-Action@main
        with:
          nuitka-version: main
          script-name: main.py
          mode: onefile
          output-file: ${{ env.APP_NAME }}
          windows-console-mode: disable
          enable-plugins: tk-inter
          include-data-dir: |
            images=images

      # ---------------------------
      # Linux: Create AppImage, then package AppImage + training/ into ONE tar.gz
      # (NO images dir shipped outside)
      # ---------------------------
      - name: Create AppImage and Linux tar.gz (Linux)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          set -euo pipefail
          rm -rf build_output stage "${DIST_DIR_NAME}"*.AppDir squashfs-root appimagetool
          mkdir -p build_output

          # Find the standalone dist directory (Nuitka creates *.dist)
          DIST_DIR="$(find . -maxdepth 4 -type d -name "*.dist" | head -n1 || true)"
          if [ -z "${DIST_DIR}" ]; then
            echo "ERROR: Could not find *.dist directory"
            find . -maxdepth 6 -type d | head -200 || true
            exit 1
          fi
          echo "Found dist directory: ${DIST_DIR}"

          # Create AppDir layout
          APPDIR="${DIST_DIR_NAME}.AppDir"
          mkdir -p "${APPDIR}/usr/bin"

          # Locate the actual executable in the dist directory
          EXEC_CANDIDATE=""
          if [ -f "${DIST_DIR}/${APP_NAME}" ]; then
            EXEC_CANDIDATE="${DIST_DIR}/${APP_NAME}"
          else
            EXEC_CANDIDATE="$(find "${DIST_DIR}" -maxdepth 1 -type f -perm -u+x | head -n1 || true)"
          fi
          if [ -z "${EXEC_CANDIDATE}" ]; then
            echo "ERROR: Could not find executable in ${DIST_DIR}"
            ls -la "${DIST_DIR}" | head -200 || true
            exit 1
          fi
          echo "Executable candidate: ${EXEC_CANDIDATE}"

          # Copy dist contents into AppDir
          cp -a "${DIST_DIR}/." "${APPDIR}/usr/bin/"

          # Ensure stable name and exec bit for AppRun
          cp -f "${EXEC_CANDIDATE}" "${APPDIR}/usr/bin/${APP_NAME}"
          chmod 755 "${APPDIR}/usr/bin/${APP_NAME}"

          # Desktop file
          cat > "${APPDIR}/${APP_NAME}.desktop" <<EOF
          [Desktop Entry]
          Type=Application
          Name=Raven Checkers
          Exec=${APP_NAME}
          Icon=${APP_NAME}
          Categories=Game;
          Terminal=false
          EOF

          # Tiny icon (1x1) to satisfy appimagetool
          python - <<'PY'
          import base64, pathlib
          png_b64 = (
              "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMA"
              "ASsJTYQAAAAASUVORK5CYII="
          )
          (pathlib.Path("${APPDIR}") / "raven-checkers.png").write_bytes(base64.b64decode(png_b64))
          PY

          # AppRun
          cat > "${APPDIR}/AppRun" <<EOF
          #!/bin/sh
          HERE="\$(dirname "\$(readlink -f "\${0}")")"
          exec "\${HERE}/usr/bin/${APP_NAME}" "\$@"
          EOF
          chmod 755 "${APPDIR}/AppRun"

          # Download appimagetool and extract (no FUSE in GitHub Actions)
          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -O appimagetool
          chmod +x appimagetool
          ./appimagetool --appimage-extract > /dev/null

          # Build AppImage
          ARCH=x86_64 ./squashfs-root/AppRun "${APPDIR}" "build_output/${APP_NAME}.AppImage"
          chmod 755 "build_output/${APP_NAME}.AppImage"

          # Stage ONE Linux folder for tar.gz: RavenCheckers/{AppImage,training/}
          rm -rf stage
          mkdir -p "stage/${DIST_DIR_NAME}"
          cp -f "build_output/${APP_NAME}.AppImage" "stage/${DIST_DIR_NAME}/${APP_NAME}.AppImage"

          if [ ! -d training ]; then
            echo "ERROR: training/ folder missing"
            exit 1
          fi
          cp -R training "stage/${DIST_DIR_NAME}/training"

          # NOTE: do NOT copy images/ â€” images are embedded into the AppImage.
          (cd stage && tar -czf "../build_output/${APP_NAME}-linux.tar.gz" "${DIST_DIR_NAME}")

          echo "Created build_output/${APP_NAME}-linux.tar.gz"
          tar -tvf "build_output/${APP_NAME}-linux.tar.gz" | head -60
        shell: bash

      # ---------------------------
      # macOS: Package onefile + training/ into tar.gz (NO images dir shipped outside)
      # ---------------------------
      - name: Stage distribution (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          set -euo pipefail
          rm -rf stage build_output
          mkdir -p "stage/${DIST_DIR_NAME}"
          mkdir -p build_output

          BIN="$(find ./build -maxdepth 6 -type f -name "${APP_NAME}" -print -quit 2>/dev/null || true)"
          if [ -z "${BIN}" ]; then
            BIN="$(find . -maxdepth 6 -type f -name "${APP_NAME}" -print -quit 2>/dev/null || true)"
          fi
          if [ -z "${BIN}" ]; then
            echo "ERROR: Could not find macOS onefile output"
            find . -maxdepth 6 -type f | head -200 || true
            exit 1
          fi

          cp "$BIN" "stage/${DIST_DIR_NAME}/${APP_NAME}"
          chmod 755 "stage/${DIST_DIR_NAME}/${APP_NAME}"

          cp -R training "stage/${DIST_DIR_NAME}/"

          (cd stage && tar -czf "../build_output/${APP_NAME}-macos.tar.gz" "${DIST_DIR_NAME}")

          echo "Created build_output/${APP_NAME}-macos.tar.gz"
          tar -tvf "build_output/${APP_NAME}-macos.tar.gz" | head -50
        shell: bash

      # ---------------------------
      # Windows: Package onefile exe + training/ into zip (NO images dir shipped outside)
      # ---------------------------
      - name: Stage distribution (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          $ErrorActionPreference = "Stop"

          Remove-Item -Recurse -Force stage, build_output -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Force -Path "stage\$env:DIST_DIR_NAME" | Out-Null
          New-Item -ItemType Directory -Force -Path "build_output" | Out-Null

          $exe = Get-ChildItem -Path build -Recurse -File -Filter "$env:APP_NAME*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $exe) {
            $exe = Get-ChildItem -Recurse -File -Filter "$env:APP_NAME*.exe" | Select-Object -First 1
          }
          if (-not $exe) {
            Write-Error "ERROR: Could not find built .exe"
            Get-ChildItem -Recurse -File | Select-Object -First 200 | ForEach-Object { $_.FullName }
            exit 1
          }

          Copy-Item $exe.FullName "stage\$env:DIST_DIR_NAME\$env:APP_NAME.exe"

          if (!(Test-Path training)) { Write-Error "ERROR: training/ folder missing"; exit 1 }
          Copy-Item -Recurse -Force training "stage\$env:DIST_DIR_NAME\training"

          Compress-Archive -Path "stage\$env:DIST_DIR_NAME" -DestinationPath "build_output\$env:APP_NAME-windows.zip" -Force

          Write-Host "Created build_output\$env:APP_NAME-windows.zip"
        shell: pwsh

      # ---------------------------
      # Upload build artifacts
      # ---------------------------
      - name: Upload build artifact (Linux)
        if: matrix.os == 'ubuntu-22.04'
        uses: actions/upload-artifact@v5
        with:
          name: linux
          path: |
            build_output/${{ env.APP_NAME }}-linux.tar.gz

      - name: Upload build artifact (macOS)
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v5
        with:
          name: macos
          path: |
            build_output/${{ env.APP_NAME }}-macos.tar.gz

      - name: Upload build artifact (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v5
        with:
          name: windows
          path: |
            build_output/${{ env.APP_NAME }}-windows.zip

  release:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Download all build artifacts
        uses: actions/download-artifact@v6
        with:
          path: downloads

      - name: Create release (if missing) and upload assets to tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ github.ref_name }}"
          echo "Target release tag: $TAG"

          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists; will upload assets with --clobber"
          else
            gh release create "$TAG" \
              --title "$TAG" \
              --notes "Automated build for $TAG"
          fi

          gh release upload "$TAG" "downloads/linux/${APP_NAME}-linux.tar.gz" --clobber
          gh release upload "$TAG" "downloads/macos/${APP_NAME}-macos.tar.gz" --clobber
          gh release upload "$TAG" "downloads/windows/${APP_NAME}-windows.zip" --clobber
