name: Build Application

on:
  push:
    tags:
      - "v[0-9]+.*"

permissions:
  contents: write

env:
  GITHUB_TOKEN: ${{ github.token }}
  APP_NAME: "raven-checkers"
  MAC_APP_NAME: "Raven Checkers"

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-22.04
            platform: linux
            python-version: "3.12"
          - os: macos-latest
            platform: macos
            python-version: "3.12"
          - os: windows-latest
            platform: windows
            python-version: "3.12"

    steps:
      - name: Check out repository
        uses: actions/checkout@v5

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          architecture: "x64"
          cache: "pip"
          cache-dependency-path: |
            **/pyproject.toml

      - uses: seanmiddleditch/gha-setup-vsdevenv@master
        if: matrix.os == 'windows-latest'

      - name: Install system packages (Ubuntu only)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          sudo apt-get update -y
          sudo apt-get install -y python3-tk imagemagick
        shell: bash

      - name: Export runtime requirements from pyproject.toml
        run: |
          python - <<'PY'
          import tomllib
          from pathlib import Path

          data = tomllib.loads(Path("pyproject.toml").read_text(encoding="utf-8"))
          deps = data.get("project", {}).get("dependencies", [])
          Path("requirements-ci.txt").write_text("\n".join(deps) + "\n", encoding="utf-8")
          print("Wrote requirements-ci.txt with", len(deps), "deps")
          PY
        shell: bash

      - name: Install dependencies
        run: |
          python -m pip install -U pip
          python -m pip install -r requirements-ci.txt
          python -m pip install nuitka
        shell: bash

      - name: Sanity check Tk import
        run: |
          python -c "import tkinter; print('ok', tkinter.TkVersion)"
        shell: bash

      # ---------------------------
      # Build with Nuitka (onefile on all OS)
      # Include BOTH images/ and training/ inside the onefile.
      # ---------------------------
      - name: Build with Nuitka (Linux)
        if: matrix.os == 'ubuntu-22.04'
        uses: Nuitka/Nuitka-Action@main
        with:
          nuitka-version: main
          script-name: main.py
          mode: onefile
          output-dir: build
          output-file: ${{ env.APP_NAME }}
          enable-plugins: tk-inter
          include-data-dir: |
            images=images
            training=training

      # ---------------------------
      # macOS: build a double-clickable .app bundle
      # Also generate an .icns from images/_raven.gif (no Homebrew).
      # ---------------------------
      - name: Create .icns icon from images/_raven.gif (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          set -euo pipefail
          rm -rf build/icon build/icon.iconset
          mkdir -p build/icon

          # Convert GIF -> PNG (sips usually supports GIF input on macOS)
          sips -s format png "images/_raven.gif" --out "build/icon/raven.png" >/dev/null

          # Create iconset at required sizes
          mkdir -p build/icon.iconset
          for size in 16 32 64 128 256 512; do
            sips -z $size $size "build/icon/raven.png" --out "build/icon.iconset/icon_${size}x${size}.png" >/dev/null
          done

          # Add true 1024x1024 source (required by macOS)
          sips -z 1024 1024 "build/icon/raven.png" --out "build/icon.iconset/icon_1024x1024.png" >/dev/null

          # Retina variants
          cp "build/icon.iconset/icon_32x32.png"   "build/icon.iconset/icon_16x16@2x.png"
          cp "build/icon.iconset/icon_64x64.png"   "build/icon.iconset/icon_32x32@2x.png"
          cp "build/icon.iconset/icon_256x256.png" "build/icon.iconset/icon_128x128@2x.png"
          cp "build/icon.iconset/icon_512x512.png" "build/icon.iconset/icon_256x256@2x.png"
          cp "build/icon.iconset/icon_512x512.png" "build/icon.iconset/icon_512x512@2x.png"
          cp "build/icon.iconset/icon_1024x1024.png" "build/icon.iconset/icon_512x512@2x.png"
          
          iconutil -c icns "build/icon.iconset" -o "build/raven.icns"
          ls -lh build/raven.icns
        shell: bash

      - name: Build with Nuitka (macOS - .app bundle)
        if: matrix.os == 'macos-latest'
        uses: Nuitka/Nuitka-Action@main
        with:
          nuitka-version: main
          script-name: main.py
          mode: standalone
          output-dir: build
          output-file: ${{ env.APP_NAME }}
          enable-plugins: tk-inter
          include-data-dir: |
            images=images
            training=training
          macos-app-mode: gui
          macos-app-name: ${{ env.MAC_APP_NAME }}
          macos-app-icon: build/raven.icns

      - name: Build with Nuitka (Windows)
        if: matrix.os == 'windows-latest'
        uses: Nuitka/Nuitka-Action@main
        with:
          nuitka-version: main
          script-name: main.py
          mode: onefile
          output-dir: build
          output-file: ${{ env.APP_NAME }}
          windows-console-mode: disable
          enable-plugins: tk-inter
          include-data-dir: |
            images=images
            training=training

      # ---------------------------
      # Linux: wrap onefile into AppImage (single download)
      # ---------------------------
      - name: Create AppImage (Linux)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          set -euo pipefail
          rm -rf build_output RavenCheckers.AppDir squashfs-root appimagetool
          mkdir -p build_output

          # Locate the Nuitka onefile binary
          BIN="$(find build -maxdepth 6 -type f -name "${APP_NAME}" -print -quit 2>/dev/null || true)"
          if [ -z "${BIN}" ] || [ ! -f "${BIN}" ]; then
            echo "ERROR: Could not find onefile binary named '${APP_NAME}' under build/"
            find build -maxdepth 6 -type f -print | head -200 || true
            exit 1
          fi
          chmod 755 "${BIN}"
          echo "Found onefile binary: ${BIN}"

          APPDIR="RavenCheckers.AppDir"
          mkdir -p "${APPDIR}/usr/bin"

          cp -f "${BIN}" "${APPDIR}/usr/bin/${APP_NAME}"
          chmod 755 "${APPDIR}/usr/bin/${APP_NAME}"

          cat > "${APPDIR}/${APP_NAME}.desktop" <<EOF
          [Desktop Entry]
          Type=Application
          Name=Raven Checkers
          Exec=${APP_NAME}
          Icon=${APP_NAME}
          Categories=Game;
          Terminal=false
          EOF

          # Icon for AppImage (use your existing gif -> png)
          convert "images/_raven.gif" "${APPDIR}/${APP_NAME}.png"

          cat > "${APPDIR}/AppRun" <<EOF
          #!/bin/sh
          HERE="\$(dirname "\$(readlink -f "\$0")")"
          exec "\${HERE}/usr/bin/${APP_NAME}" "\$@"
          EOF
          chmod 755 "${APPDIR}/AppRun"

          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -O appimagetool
          chmod +x appimagetool
          ./appimagetool --appimage-extract > /dev/null

          ARCH=x86_64 ./squashfs-root/AppRun "${APPDIR}" "build_output/${APP_NAME}.AppImage"
          chmod 755 "build_output/${APP_NAME}.AppImage"

          ls -lh build_output/
        shell: bash

      # ---------------------------
      # macOS: locate the onefile binary for upload
      # ---------------------------
      - name: Prepare macOS artifact (create DMG)
        if: matrix.os == 'macos-latest'
        run: |
          set -euo pipefail
          rm -rf build_output
          mkdir -p build_output

          APP_PATH="$(find build -maxdepth 6 -type d -name "*.app" -print -quit 2>/dev/null || true)"
          if [ -z "${APP_PATH}" ] || [ ! -d "${APP_PATH}" ]; then
            echo "ERROR: Could not find macOS app bundle under build/"
            find build -maxdepth 6 -print | head -200 || true
            exit 1
          fi
          echo "Found app bundle: ${APP_PATH}"

          # Create a single-file DMG (double-clickable distribution)
          hdiutil create \
            -volname "${MAC_APP_NAME}" \
            -srcfolder "${APP_PATH}" \
            -ov -format UDZO \
            "build_output/${APP_NAME}.dmg"

          ls -lh build_output/
        shell: bash

      # ---------------------------
      # Windows: locate the exe for upload
      # ---------------------------
      - name: Prepare Windows artifact
        if: matrix.os == 'windows-latest'
        run: |
          $ErrorActionPreference = "Stop"
          Remove-Item -Recurse -Force build_output -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Force -Path "build_output" | Out-Null

          $exe = Get-ChildItem -Path build -Recurse -File -Filter "$env:APP_NAME*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $exe) { $exe = Get-ChildItem -Path build -Recurse -File -Filter "main*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1 }
          if (-not $exe) {
            Write-Error "ERROR: Could not find built .exe under build/"
            Get-ChildItem -Path build -Recurse -File | Select-Object -First 200 | ForEach-Object { $_.FullName }
            exit 1
          }

          Copy-Item $exe.FullName "build_output\$env:APP_NAME.exe"
          Get-ChildItem build_output | Format-List
        shell: pwsh

      # ---------------------------
      # Upload build artifacts (single-file per OS)
      # ---------------------------
      - name: Upload artifact (Linux AppImage)
        if: matrix.os == 'ubuntu-22.04'
        uses: actions/upload-artifact@v5
        with:
          name: linux
          path: build_output/${{ env.APP_NAME }}.AppImage

      - name: Upload artifact (macOS onefile)
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v5
        with:
          name: macos
          path: build_output/${{ env.APP_NAME }}.dmg

      - name: Upload artifact (Windows exe)
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v5
        with:
          name: windows
          path: build_output/${{ env.APP_NAME }}.exe

  release:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v6
        with:
          path: downloads

      - name: Create release (if missing) and upload assets to tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ github.ref_name }}"
          echo "Target release tag: $TAG"

          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists; will upload assets with --clobber"
          else
            gh release create "$TAG" \
              --title "$TAG" \
              --notes "Automated build for $TAG"
          fi

          gh release upload "$TAG" "downloads/linux/${APP_NAME}.AppImage" --clobber
          gh release upload "$TAG" "downloads/macos/${APP_NAME}.dmg" --clobber
          gh release upload "$TAG" "downloads/windows/${APP_NAME}.exe" --clobber
